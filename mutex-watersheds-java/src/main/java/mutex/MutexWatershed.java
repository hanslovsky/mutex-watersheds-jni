/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mutex;

import net.imglib2.Cursor;
import net.imglib2.Dimensions;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.type.numeric.RealType;
import net.imglib2.util.Intervals;
import net.imglib2.view.Views;
import net.imglib2.view.composite.Composite;


public class MutexWatershed {

    public static <T extends RealType<T>, C extends Composite<T>> int[] mutexWatershed(
            final RandomAccessibleInterval<C> affinities,
            final long[]... offsets
    ) {
        final int[] assignments = new int[(int) Intervals.numElements(affinities)];
        // NOTE Iterating over RAI in Rust JNI is extremely slow and generating the graph takes a long time.
        //      It is faster to copy from RAI into double[], then copy from double[] to Vec with a single call.
        //      native implementation mutexWatershed is preferred over
        //      native implementation mutexWatershedFromRAI
        mutexWatershedImpl(affinities, assignments, makeOffsetStrides(affinities, offsets));
        // mutexWatershedImplFromRAI(affinities, assignments, makeOffsetStrides(affinities, offsets));
        return assignments;
    };

    private static <T extends RealType<T>, C extends Composite<T>> void mutexWatershedImplFromRAI(
            final RandomAccessibleInterval<C> affinities,
            final int[] assignments,
            final long... offsetStrides
    ) {
        mutexWatershedFromRAI(affinities, assignments, offsetStrides);
    }

    private static <T extends RealType<T>, C extends Composite<T>> void mutexWatershedImpl(
            final RandomAccessibleInterval<C> affinities,
            final int[] assignments,
            final long... offsetStrides
    ) {
        final double[] affinitiesArray = new double[((int)Intervals.numElements(affinities)) * offsetStrides.length];
        final Cursor<C> cursor = Views.flatIterable(affinities).cursor();
        for (int index = 0; index < affinitiesArray.length;) {
            final C composite = cursor.next();
            for (int offsetIndex = 0; offsetIndex < offsetStrides.length; ++offsetIndex) {
                affinitiesArray[index] = composite.get(offsetIndex).getRealDouble();
                ++index;
            }
        }
        mutexWatershed(affinitiesArray, assignments, offsetStrides);
    }

    private static native <T extends RealType<T>, C extends Composite<T>> void mutexWatershedFromRAI(
            final RandomAccessibleInterval<C> affinities,
            final int[] assignments,
            final long... offsetStrides
    );

    private static native <T extends RealType<T>, C extends Composite<T>> void mutexWatershed(
            final double[] affinities,
            final int[] assignments,
            final long... offsetStrides
    );

    private static long[] makeOffsetStrides(
            final Dimensions dimensions,
            final long[]... offsets) {
        final long[] strides = new long[dimensions.numDimensions()];
        strides[0] = 1L;
        for (int d = 1; d < strides.length; ++d)
            strides[d] = strides[d-1] * dimensions.dimension(d-1);
        final long[] offsetStrides = new long[offsets.length];
        for (int i = 0; i < offsetStrides.length; ++i)
            for (int d = 0; d < offsets[i].length; ++d)
                offsetStrides[i] += strides[d] * offsets[i][d];
        return offsetStrides;
    }

    static {
        System.loadLibrary("mutex_watersheds_jni");
    }
}
